/* eslint-disable camelcase */
import util from '../util';
import path from 'path'
import { testClient, TestClient } from '../util'
import { DocumentNode } from 'graphql'

import gql from 'graphql-tag'

function loadQueryNode (name: string): Promise<DocumentNode> {
  return util.loadQueryNode(path.resolve(__dirname, '..', 'new', 'example_queries', 'blocks'), name)
}

const allFieldsPopulated = (obj: any) => {
  let k: keyof typeof obj
  for (k in obj) {
    if (
      typeof k === 'object'
    ) {
      allFieldsPopulated(k)
    }
    expect(k).not.toBeNull()
  }
}

describe('blocks', () => {
  let client: TestClient
  beforeAll(async () => {
    client = await testClient.preprod()
  })

  // FIX FAIL  it('caps the response to 100 blocks', async () => {
  //   const result = await client.query({
  //     query: await loadQueryNode('blockHashesNoArgs')
  //   })

    
  //   util.saveResult(result.data, "new",   "blocks", "blockHashesNoArgs.json");

  //   expect(((result.data as any) as any).blocks.length).toBe(2500)
  // })

  // FIX FAIL it('allows custom pagination size with a limit and offset', async () => {
    // const page1 = await client.query({
    //   query: await loadQueryNode('first20Blocks')
    // })

    // util.saveResult(page1.data, "new",   "blocks", "first20Blocks.json");

    // expect((page1.data as any) .blocks.length).toBe(20)
    // expect((page1.data as any).blocks[19].number).toBe(23)

    // const page2 = await client.query({
    //   query: await loadQueryNode('second20Blocks')
    // })

    // util.saveResult(page2.data, "new",   "blocks", "second20Blocks.json");


    // expect((page2.data as any).blocks.length).toBe(20)
    // expect((page2.data as any).blocks[19].number).toBe(43)
    //})

  // FIX FAIL it('Can return blocks by number', async () => {
  //   const result = await client.query({
  //     query: await loadQueryNode('blockByNumbers'),
  //     variables: { numbers: [100, 200] }
  //   })

  //   util.saveResult(result.data, "new",   "blocks", "blockByNumbers.json");

  //   expect((result.data as any).blocks.length).toBe(2)
  //   expect((result.data as any).blocks[0].hash).not.toBeNull()
  //   expect((result.data as any).blocks[1].hash).not.toBeNull()
  // })

  // Todo: Restore. Assertion is valid, but matcher seems to have 'ArrayContaining [ObjectContaining' appended
  // it('Can return blocks by an array of hashes', async () => {
  //   const result = await client.query({
  //     query: await loadQueryNode('blocksByHashes'),
  //     variables: { hashes: [block29021.basic.hash, block29022.basic.hash] }
  //   })
  //   expect((result.data as any).blocks.length).toBe(2)
  //   console.log()
  //   expect((result.data as any).blocks).toEqual(
  //     expect.arrayContaining([
  //       expect.objectContaining(block29021.basic),
  //       expect.objectContaining(block29022.basic)
  //     ])
  //   )
  // })

  // it('Can return aggregated data', async () => {
  //   const result = await client.query({
  //     query: await loadQueryNode('aggregateDataWithinBlock'),
  //     variables: { number: 283413, epochLessThan: 50 }
  //   })

  //   util.saveResult(result.data, "new",   "blocks", "aggregateDataWithinBlock.json");

  //   allFieldsPopulated((result.data as any).blocks[0])
  // })


  // FIX FAIL it('Can return filtered aggregated data', async () => {
  //   const result = await client.query({
  //     query: gql`query {
  //         blocks( where: { number: { _eq: 283413 }}) {
  //             transactions_aggregate(
  //                 where: {
  //                     _and: [
  //                         { fee: { _gt: "10" }},
  //                         { totalOutput: { _lt: "4924799478670" } }
  //                     ]
  //                 }) {
  //                  aggregate {
  //                   sum {
  //                       size
  //                   }
  //                  }
  //             }
  //             number
  //         }
  //     }`
  //   })

  //   // const result = await client.query({
  //   //   query: gql`query {
  //   //       blocks( where: { number: { _eq: 283413 }}) {
  //   //           transactions_aggregate(
  //   //               where: {
  //   //                   _and: [
  //   //                       { fee: { _gt: "10" }},
  //   //                       { totalOutput: { _lt: "4924799478670" } }
  //   //                   ]
  //   //               }) {
  //   //               aggregate {
  //   //                   count
  //   //               }
  //   //           }
  //   //           number
  //   //       }
  //   //   }`
  //   // })

  //   util.saveResult(result.data, "new",   "blocks", "cant_return_filtered_aggregated_data.json");

  //   expect((result.data as any)).toMatchSnapshot()
  // })

  it('are linked to their predecessor, and the chain can be traversed', async () => {
    const result = await client.query({
      query: await loadQueryNode('selectGreatGrandparentBlock'),
      variables: { number: 29022 }
    })

    util.saveResult(result.data, "new",   "blocks", "selectGreatGrandparentBlock.json");

    // FIX FAIL expect((result.data as any).blocks[0].previousBlock.previousBlock.previousBlock.number).toBe(29019)
    // FIX FAIL expect((result.data as any)).toMatchSnapshot()
  })

  it('are linked to their successor, and the chain can be traversed', async () => {
    const result = await client.query({
      query: await loadQueryNode('selectGreatGrandchildBlock'),
      variables: { number: 29022 }
    })

    util.saveResult(result.data, "new",   "blocks", "selectGreatGrandchildBlock.json");

    // FIX FAIL expect((result.data as any).blocks[0].nextBlock.nextBlock.nextBlock.number).toBe(29025)
    // FIX FAIL expect((result.data as any)).toMatchSnapshot()
  })
})
